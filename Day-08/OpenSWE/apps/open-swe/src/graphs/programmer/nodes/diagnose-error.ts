/**
 * @file Programmer의 에러 진단 노드
 * @description
 * 도구 실행이 연속으로 실패했을 때 LLM을 사용하여 에러를 분석하고 해결 방법을 제시하는 노드입니다.
 * 실패한 명령의 출력, 현재 작업, 코드베이스 구조, 대화 기록을 종합하여 정확한 진단을 수행합니다.
 *
 * 주요 기능:
 * - 마지막 실패한 도구 호출 탐지
 * - LLM을 사용한 에러 원인 분석
 * - 코드베이스 트리 컨텍스트 제공
 * - 구조화된 진단 결과 생성
 * - 진단 메시지를 대화 기록에 추가
 *
 * 워크플로우:
 * 1. 실패한 ToolMessage 찾기 (status === "error")
 * 2. 시스템 프롬프트 구성 (에러 출력, 현재 작업, 코드베이스 트리)
 * 3. 사용자 프롬프트 구성 (대화 기록)
 * 4. LLM 호출 (diagnose_error 도구 강제 사용)
 * 5. 진단 결과를 ToolMessage로 변환하여 반환
 */

// 외부 라이브러리
import { v4 as uuidv4 } from "uuid"; // UUID 생성

// LangChain 메시지 타입
import {
  BaseMessage, // 메시지 기본 타입
  isToolMessage, // ToolMessage 타입 가드
  ToolMessage, // 도구 실행 결과 메시지
} from "@langchain/core/messages";

// Open SWE 공유 타입
import {
  GraphConfig, // LangGraph 설정 타입
  GraphState, // 그래프 전역 상태 타입
  GraphUpdate, // 상태 업데이트 타입
  PlanItem, // 개별 계획 항목 타입
} from "@openswe/shared/open-swe/types";

// 유틸리티 함수
import { createDiagnoseErrorToolFields } from "@openswe/shared/open-swe/tools"; // 에러 진단 도구 정의
import { formatPlanPromptWithSummaries } from "../../../utils/plan-prompt.js"; // 계획 프롬프트 포맷팅
import { getMessageString } from "../../../utils/message/content.js"; // 메시지 문자열 변환
import { getMessageContentString } from "@openswe/shared/messages"; // 메시지 내용 추출
import {
  loadModel, // LLM 모델 로더
  supportsParallelToolCallsParam, // 병렬 도구 호출 지원 여부
} from "../../../utils/llms/index.js";
import { LLMTask } from "@openswe/shared/open-swe/llm-task"; // LLM 작업 타입 (SUMMARIZER)
import { z } from "zod"; // Zod 스키마 타입 추론
import { createLogger, LogLevel } from "../../../utils/logger.js"; // 로거 생성
import {
  getCompletedPlanItems, // 완료된 계획 항목 목록
  getCurrentPlanItem, // 현재 진행 중인 계획 항목
} from "../../../utils/current-task.js";
import { getActivePlanItems } from "@openswe/shared/open-swe/tasks"; // 활성 계획 항목 목록

// 로거 인스턴스 생성
const logger = createLogger(LogLevel.INFO, "DiagnoseError");

/**
 * 에러 진단을 위한 시스템 프롬프트 템플릿
 *
 * @description
 * LLM에게 실패한 명령, 현재 작업, 코드베이스 구조를 제공하고
 * 에러를 정확하게 진단하도록 안내하는 프롬프트입니다.
 *
 * 진단 규칙:
 * - 명확하고 간결한 설명 제공
 * - 직접 관련된 정보만 포함
 * - 추측 금지 - 제공된 정보에만 기반
 * - 특정 코드 라인 또는 컨텍스트 참조
 *
 * @constant {string}
 */
const systemPrompt = `You are operating as a terminal-based agentic coding assistant built by LangChain. It wraps LLM models to enable natural language interaction with a local codebase. You are expected to be precise, safe, and helpful.

The last command you tried to execute failed with an error. Please carefully diagnose the error, and provide a helpful explanation of exactly what the issue is, and how you can fix it.

Following these rules when diagnosing the error:
  - You should provide a clear, concise, and helpful explanation of exactly what the issue is, and how you can fix it.
  - You do not want to be overly verbose in your diagnosis. You should only include information which is directly relevant to diagnosing and fixing the error.
  - NEVER make up reasons, or make a guess as to what the issue is. Your reasoning must ALWAYS be grounded in the information provided to you.
    - Making up reasons, or making a guess can lead to more problems, so it's best to say you don't know rather than make up a reason.
  - Reference specific lines of code, or context from the conversation history to support your diagnosis.

Here is the result of the last two failed commands:
{FAILED_ACTION_OUTPUT}

Here is the current task you're working on:
{CURRENT_TASK}

And here are all of the tasks you've completed so far, along with their summaries:
{PLAN_PROMPT}

Below is an up to date tree of the codebase (going 3 levels deep). This is up to date, and is updated after every action you take. Always assume this is the most up to date context about the codebase.
It was generated by using the \`tree\` command, passing in the gitignore file to ignore files and directories you should not have access to (\`git ls-files | tree --fromfile -L 3\`). It is always executed inside the repo directory: {REPO_DIRECTORY}
{CODEBASE_TREE}

Please carefully go over all of this information, and provide a helpful explanation of exactly what the issue is, and how you can fix it. When you are ready to provide your diagnosis, call the \`diagnose_error\` tool.
`;

/**
 * 에러 진단을 위한 사용자 프롬프트 템플릿
 *
 * @description
 * 전체 대화 기록을 제공하여 LLM이 컨텍스트를 이해하고
 * 더 정확한 진단을 할 수 있도록 합니다.
 *
 * @constant {string}
 */
const userPrompt = `Here is the full conversation history from the steps taken to complete the current task, along with the user's initial request:

{CONVERSATION_HISTORY}

Please carefully go over all of this information, and provide a helpful explanation of exactly what the issue is, and how you can fix it. When you are ready to provide your diagnosis, call the \`diagnose_error\` tool.`;

/**
 * 에러 진단 도구 정의
 *
 * @description
 * LLM이 진단 결과를 구조화된 형식으로 반환하도록 하는 도구입니다.
 * tool_choice로 강제 호출되어 반드시 진단을 생성합니다.
 *
 * @constant
 */
const diagnoseErrorTool = createDiagnoseErrorToolFields();

/**
 * 시스템 프롬프트를 포맷팅합니다
 *
 * @description
 * 실패한 명령의 출력, 현재 작업, 완료된 작업 요약, 코드베이스 트리를
 * 시스템 프롬프트 템플릿에 삽입합니다.
 *
 * @param {string} lastFailedActionContent - 실패한 도구 호출의 출력 내용
 * @param {PlanItem[]} taskPlan - 활성 계획 항목 배열
 * @param {string} codebaseTree - 코드베이스 디렉토리 트리 (3단계 깊이)
 * @returns {string} 포맷팅된 시스템 프롬프트
 */
const formatSystemPrompt = (
  lastFailedActionContent: string,
  taskPlan: PlanItem[],
  codebaseTree: string,
): string => {
  const currentPlanItem = getCurrentPlanItem(taskPlan);
  const completedTasks = getCompletedPlanItems(taskPlan);

  return systemPrompt
    .replace(
      "{FAILED_ACTION_OUTPUT}",
      `<failed-action-output>${lastFailedActionContent}</failed-action-output>`,
    )
    .replace(
      "{CURRENT_TASK}",
      `<current-task index="${currentPlanItem.index}">${currentPlanItem.plan}</current-task>`,
    )
    .replace("{PLAN_PROMPT}", formatPlanPromptWithSummaries(completedTasks))
    .replace(
      "{CODEBASE_TREE}",
      `<codebase-tree>\n${codebaseTree || "No codebase tree generated yet."}\n</codebase-tree>`,
    );
};

/**
 * 사용자 프롬프트를 포맷팅합니다
 *
 * @description
 * 전체 대화 기록을 문자열로 변환하여 사용자 프롬프트에 삽입합니다.
 * 이를 통해 LLM이 이전 컨텍스트를 참고할 수 있습니다.
 *
 * @param {BaseMessage[]} messages - 내부 메시지 배열 (대화 기록)
 * @returns {string} 포맷팅된 사용자 프롬프트
 */
const formatUserPrompt = (messages: BaseMessage[]): string => {
  return userPrompt.replace(
    "{CONVERSATION_HISTORY}",
    messages.map(getMessageString).join("\n"),
  );
};

/**
 * 에러를 진단하고 해결 방법을 제시하는 노드 함수입니다
 *
 * @description
 * 마지막 도구 호출이 실패했을 때 호출됩니다.
 * LLM을 사용하여 에러 원인을 분석하고, 구조화된 진단 결과를 생성합니다.
 *
 * 처리 흐름:
 * 1. 마지막 실패한 ToolMessage 찾기 (status === "error")
 * 2. SUMMARIZER 타입의 LLM 모델 로드
 * 3. diagnose_error 도구를 강제 호출하도록 모델 바인딩
 * 4. 시스템/사용자 프롬프트 구성 및 LLM 호출
 * 5. 도구 호출 응답 검증
 * 6. 진단 결과를 ToolMessage로 변환
 * 7. 메시지 배열에 추가하여 반환
 *
 * @param {GraphState} state - 현재 그래프 상태 (메시지, TaskPlan, 코드베이스 트리 포함)
 * @param {GraphConfig} config - 그래프 설정 (모델 설정 등)
 * @returns {Promise<GraphUpdate>} 진단 메시지를 포함한 상태 업데이트
 * @throws {Error} 실패한 액션을 찾을 수 없거나 도구 호출 생성 실패 시
 *
 * @example
 * // 도구 실행 실패 후 호출
 * const update = await diagnoseError(state, config);
 * // => { messages: [AIMessage, ToolMessage], internalMessages: [...] }
 */
export async function diagnoseError(
  state: GraphState,
  config: GraphConfig,
): Promise<GraphUpdate> {
  // === 1단계: 마지막 실패한 도구 호출 찾기 ===
  const lastFailedAction = state.internalMessages.findLast(
    (m) => isToolMessage(m) && m.status === "error",
  );

  // 실패한 액션이 없으면 에러
  if (!lastFailedAction?.content) {
    throw new Error("No failed action found in messages");
  }

  logger.info("The last two tool calls resulted in errors. Diagnosing error.");

  // === 2단계: LLM 모델 로드 및 도구 바인딩 ===
  const model = await loadModel(config, LLMTask.SUMMARIZER);
  const modelSupportsParallelToolCallsParam = supportsParallelToolCallsParam(
    config,
    LLMTask.SUMMARIZER,
  );

  // diagnose_error 도구를 강제 호출하도록 설정
  const modelWithTools = model.bindTools([diagnoseErrorTool], {
    tool_choice: diagnoseErrorTool.name, // 반드시 이 도구 사용
    ...(modelSupportsParallelToolCallsParam
      ? {
          parallel_tool_calls: false, // 병렬 호출 비활성화
        }
      : {}),
  });

  // === 3단계: LLM 호출 ===
  const response = await modelWithTools.invoke([
    {
      role: "system",
      content: formatSystemPrompt(
        getMessageContentString(lastFailedAction.content),
        getActivePlanItems(state.taskPlan),
        state.codebaseTree,
      ),
    },
    {
      role: "user",
      content: formatUserPrompt(state.internalMessages),
    },
  ]);

  // === 4단계: 도구 호출 응답 검증 ===
  const toolCall = response.tool_calls?.[0];

  if (!toolCall) {
    throw new Error("Failed to generate a tool call when diagnosing error.");
  }

  logger.info("Diagnosed error successfully.", {
    diagnosis: (toolCall.args as z.infer<typeof diagnoseErrorTool.schema>)
      .diagnosis,
  });

  // === 5단계: 진단 성공 ToolMessage 생성 ===
  const toolMessage = new ToolMessage({
    id: uuidv4(),
    tool_call_id: toolCall.id ?? "",
    content: `Successfully diagnosed error. Please use the diagnosis to continue with the next action.`,
    name: toolCall.name,
    status: "success",
    additional_kwargs: {
      is_diagnosis: true, // 진단 메시지임을 표시
    },
  });

  // === 6단계: 상태 업데이트 반환 ===
  return {
    messages: [response, toolMessage], // 사용자에게 보여줄 메시지
    internalMessages: [response, toolMessage], // 내부 대화 기록
  };
}
