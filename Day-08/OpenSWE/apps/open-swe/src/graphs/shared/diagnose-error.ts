/**
 * @file 에러 진단 공유 노드
 * @description
 * 도구 실행 중 발생한 에러를 LLM을 사용하여 진단하고 해결책을 제시하는 공유 노드입니다.
 *
 * 이 노드는 모든 그래프(Planner, Programmer, Reviewer)에서 공통으로 사용되며,
 * 도구 호출 실패 시 자동으로 호출되어 에러 원인을 분석하고 다음 단계를 결정합니다.
 *
 * 주요 기능:
 * 1. 실패한 도구 호출 정보 수집
 * 2. LLM을 사용한 에러 원인 분석
 * 3. 코드베이스 컨텍스트를 활용한 정확한 진단
 * 4. 구체적이고 실행 가능한 해결책 제시
 *
 * 워크플로우:
 * - 도구 실행 실패 감지
 * - 에러 메시지 및 컨텍스트 수집
 * - LLM에게 진단 요청 (diagnose_error 도구 호출 강제)
 * - 진단 결과를 ToolMessage로 반환
 * - 이전 노드로 복귀하여 수정된 접근 방식으로 재시도
 */

// UUID 생성 함수 (고유 메시지 ID 할당용)
import { v4 as uuidv4 } from "uuid";

// LangChain 메시지 타입
import {
  BaseMessage,   // 메시지 기본 타입
  isToolMessage, // ToolMessage 타입 가드 함수
  ToolMessage,   // 도구 실행 결과 메시지
} from "@langchain/core/messages";

// 에러 진단 도구 스키마 생성 함수
import { createDiagnoseErrorToolFields } from "@openswe/shared/open-swe/tools";

// Zod 스키마 라이브러리 (타입 검증용)
import { z } from "zod";

// 그래프 타입 정의
import { ModelTokenData, GraphConfig } from "@openswe/shared/open-swe/types";

// 로깅 유틸리티
import { createLogger, LogLevel } from "../../utils/logger.js";

// 에러 메시지 추출 유틸리티
import { getAllLastFailedActions } from "../../utils/tool-message-error.js";

// 메시지 문자열 변환 유틸리티
import { getMessageString } from "../../utils/message/content.js";

// LLM 모델 로드 및 설정 유틸리티
import {
  loadModel,                     // 설정에 맞는 LLM 모델 로드
  supportsParallelToolCallsParam, // 병렬 도구 호출 지원 여부 확인
} from "../../utils/llms/index.js";

// LLM 작업 타입 열거형
import { LLMTask } from "@openswe/shared/open-swe/llm-task";

// 캐싱 성능 추적 유틸리티
import { trackCachePerformance } from "../../utils/caching.js";

// 모델 관리자 (모델 이름 조회용)
import { getModelManager } from "../../utils/llms/model-manager.js";

// 로거 인스턴스 생성 (에러 진단 전용)
const logger = createLogger(LogLevel.INFO, "SharedDiagnoseError");

/**
 * 에러 진단을 위한 시스템 프롬프트
 *
 * @description
 * LLM에게 에러 진단 작업의 목적, 규칙, 제공되는 컨텍스트를 명확히 설명합니다.
 * 이 프롬프트는 LLM이 정확하고 실용적인 진단을 제공하도록 유도합니다.
 *
 * 핵심 지침:
 * - 명확하고 간결한 설명 제공
 * - 추측하지 않고 제공된 정보에만 기반한 분석
 * - 구체적인 코드 라인 또는 컨텍스트 참조
 * - 실행 가능한 해결책 제시
 *
 * 제공 정보:
 * - 실패한 도구 호출 출력 (FAILED_ACTIONS_OUTPUTS)
 * - 최신 코드베이스 트리 (CODEBASE_TREE)
 *
 * @constant {string}
 */
const systemPrompt = `You are operating as a terminal-based agentic coding assistant built by LangChain. It wraps LLM models to enable natural language interaction with a local codebase. You are expected to be precise, safe, and helpful.

The last few commands you tried to execute failed with an error. Please carefully diagnose the error, and provide a helpful explanation of exactly what the issue is, and how you can fix it.

Following these rules when diagnosing the error:
  - You should provide a clear, concise, and helpful explanation of exactly what the issue is, and how you can fix it.
  - You do not want to be overly verbose in your diagnosis. You should only include information which is directly relevant to diagnosing and fixing the error.
  - NEVER make up reasons, or make a guess as to what the issue is. Your reasoning must ALWAYS be grounded in the information provided to you.
    - Making up reasons, or making a guess can lead to more problems, so it's best to say you don't know rather than make up a reason.
  - Reference specific lines of code, or context from the conversation history to support your diagnosis.

Here are the last actions you attempted which resulted in errors:
{FAILED_ACTIONS_OUTPUTS}

Below is an up to date tree of the codebase (going 3 levels deep). This is up to date, and is updated after every action you take. Always assume this is the most up to date context about the codebase.
It was generated by using the \`tree\` command, passing in the gitignore file to ignore files and directories you should not have access to (\`git ls-files | tree --fromfile -L 3\`). It is always executed inside the repo directory: {REPO_DIRECTORY}
{CODEBASE_TREE}

Please carefully go over all of this information, and provide a helpful explanation of exactly what the issue is, and how you can fix it. When you are ready to provide your diagnosis, call the \`diagnose_error\` tool.
`;

/**
 * 에러 진단을 위한 사용자 프롬프트
 *
 * @description
 * 전체 대화 히스토리를 LLM에게 제공하여 에러가 발생한 컨텍스트를 이해하도록 합니다.
 * 사용자의 원래 요청과 그동안의 실행 단계를 모두 포함합니다.
 *
 * @constant {string}
 */
const userPrompt = `Here is the full conversation history from the steps taken to complete the current task, along with the user's initial request:

{CONVERSATION_HISTORY}

Please carefully go over all of this information, and provide a helpful explanation of exactly what the issue is, and how you can fix it. When you are ready to provide your diagnosis, call the \`diagnose_error\` tool.`;

/**
 * 에러 진단 도구 스키마
 *
 * @description
 * LLM이 진단 결과를 구조화된 형식으로 반환하기 위해 호출하는 도구의 스키마입니다.
 * 이 도구 호출을 강제함으로써 진단 결과가 일관된 형식을 유지하도록 보장합니다.
 *
 * @constant
 */
const diagnoseErrorTool = createDiagnoseErrorToolFields();

/**
 * 시스템 프롬프트를 포맷팅하는 헬퍼 함수
 *
 * @description
 * 시스템 프롬프트 템플릿에 실제 에러 정보와 코드베이스 트리를 삽입합니다.
 * 플레이스홀더를 실제 데이터로 치환하여 LLM에게 제공할 완전한 프롬프트를 생성합니다.
 *
 * @param {BaseMessage[]} messages - 전체 메시지 히스토리
 *   - 이 중에서 실패한 ToolMessage들을 찾아 에러 정보 추출
 * @param {string} codebaseTree - 현재 코드베이스의 디렉토리 구조
 *   - tree 명령으로 생성된 3레벨 깊이의 디렉토리 트리
 *
 * @returns {string} 포맷팅된 시스템 프롬프트
 */
const formatSystemPrompt = (
  messages: BaseMessage[],
  codebaseTree: string,
): string => {
  // 메시지 히스토리에서 최근 실패한 도구 호출들의 에러 메시지 추출
  const lastFailedActions = getAllLastFailedActions(messages);

  // 시스템 프롬프트 템플릿의 플레이스홀더를 실제 데이터로 치환
  return systemPrompt
    .replace(
      "{FAILED_ACTIONS_OUTPUTS}",
      `<failed-action-output>${lastFailedActions}</failed-action-output>`,
    )
    .replace(
      "{CODEBASE_TREE}",
      `<codebase-tree>\n${codebaseTree || "No codebase tree generated yet."}\n</codebase-tree>`,
    );
};

/**
 * 사용자 프롬프트를 포맷팅하는 헬퍼 함수
 *
 * @description
 * 사용자 프롬프트 템플릿에 전체 대화 히스토리를 삽입합니다.
 * 모든 메시지를 문자열로 변환하여 LLM이 컨텍스트를 이해할 수 있도록 합니다.
 *
 * @param {BaseMessage[]} messages - 전체 메시지 히스토리
 * @returns {string} 포맷팅된 사용자 프롬프트
 */
const formatUserPrompt = (messages: BaseMessage[]): string => {
  return userPrompt.replace(
    "{CONVERSATION_HISTORY}",
    // 각 메시지를 문자열로 변환하여 줄바꿈으로 연결
    messages.map(getMessageString).join("\n"),
  );
};

/**
 * 에러 진단 노드의 입력 상태 인터페이스
 *
 * @interface DiagnoseErrorInputs
 * @property {BaseMessage[]} messages - 전체 메시지 히스토리 (에러 메시지 포함)
 * @property {string} codebaseTree - 코드베이스 디렉토리 구조
 * @property {ModelTokenData[]} [tokenData] - 선택적 토큰 사용량 데이터
 */
interface DiagnoseErrorInputs {
  messages: BaseMessage[];
  codebaseTree: string;
  tokenData?: ModelTokenData[];
}

/**
 * 에러 진단 노드의 출력 상태 타입
 *
 * @description
 * 입력 상태의 부분 업데이트를 반환합니다. (Partial 타입 사용)
 * 진단 결과 메시지와 토큰 사용량 정보를 포함합니다.
 */
type DiagnoseErrorUpdate = Partial<DiagnoseErrorInputs>;

/**
 * 에러 진단 노드 함수
 *
 * @description
 * 도구 실행 실패 시 LLM을 사용하여 에러를 진단하고 해결책을 제시하는 공유 노드입니다.
 * 모든 그래프(Planner, Programmer, Reviewer)에서 사용됩니다.
 *
 * 처리 흐름:
 * 1. 마지막 실패한 도구 호출 확인
 * 2. SUMMARIZER 작업용 LLM 모델 로드
 * 3. diagnose_error 도구를 바인딩하고 도구 호출 강제
 * 4. 시스템 및 사용자 프롬프트로 LLM 호출
 * 5. 진단 결과를 ToolMessage로 변환하여 반환
 *
 * @param {DiagnoseErrorInputs} state - 현재 그래프 상태
 *   - messages: 에러를 포함한 전체 메시지 히스토리
 *   - codebaseTree: 코드베이스 구조 (컨텍스트 제공용)
 *
 * @param {GraphConfig} config - 그래프 설정
 *   - LLM 모델 선택 및 인증 정보
 *
 * @returns {Promise<DiagnoseErrorUpdate>} 상태 업데이트 객체
 *   - messages: AI 응답과 진단 결과 ToolMessage
 *   - tokenData: 캐싱 성능 추적 데이터
 *
 * @throws {Error} 실패한 도구 호출이 없을 때
 * @throws {Error} LLM이 도구 호출을 생성하지 못했을 때
 *
 * @example
 * // Programmer 그래프에서 파일 편집 실패 시
 * state = {
 *   messages: [
 *     AIMessage({ tool_calls: [{ name: "edit_file", ... }] }),
 *     ToolMessage({ status: "error", content: "File not found" })
 *   ],
 *   codebaseTree: "src/\n  utils/\n    ..."
 * }
 * result = await diagnoseError(state, config);
 * // result.messages에 진단 결과와 해결책이 포함됨
 */
export async function diagnoseError(
  state: DiagnoseErrorInputs,
  config: GraphConfig,
): Promise<DiagnoseErrorUpdate> {
  // === 1단계: 실패한 도구 호출 확인 ===
  // 메시지 히스토리에서 마지막 에러 상태의 ToolMessage 찾기
  const lastFailedAction = state.messages.findLast(
    (m) => isToolMessage(m) && m.status === "error",
  );

  // 실패한 액션이 없으면 에러 (이 노드가 잘못 호출됨)
  if (!lastFailedAction?.content) {
    throw new Error("No failed action found in messages");
  }

  // 에러 진단 시작 로그
  logger.info("The last few tool calls resulted in errors. Diagnosing error.");

  // === 2단계: LLM 모델 준비 ===
  // SUMMARIZER 작업용 모델 로드 (에러 분석 및 요약에 적합)
  const model = await loadModel(config, LLMTask.SUMMARIZER);

  // 모델 이름 조회 (토큰 추적용)
  const modelManager = getModelManager();
  const modelName = modelManager.getModelNameForTask(
    config,
    LLMTask.SUMMARIZER,
  );

  // 모델의 병렬 도구 호출 지원 여부 확인
  const modelSupportsParallelToolCallsParam = supportsParallelToolCallsParam(
    config,
    LLMTask.SUMMARIZER,
  );

  // === 3단계: 도구 바인딩 및 설정 ===
  // diagnose_error 도구를 모델에 바인딩하고 도구 호출 강제
  const modelWithTools = model.bindTools([diagnoseErrorTool], {
    tool_choice: diagnoseErrorTool.name, // 반드시 이 도구를 호출하도록 강제
    ...(modelSupportsParallelToolCallsParam
      ? {
          parallel_tool_calls: false, // 진단은 하나씩만 수행
        }
      : {}),
  });

  // === 4단계: LLM 호출 ===
  // 시스템 프롬프트와 사용자 프롬프트로 LLM에 진단 요청
  const response = await modelWithTools.invoke([
    {
      role: "system",
      content: formatSystemPrompt(state.messages, state.codebaseTree),
    },
    {
      role: "user",
      content: formatUserPrompt(state.messages),
    },
  ]);

  // === 5단계: 도구 호출 결과 검증 ===
  const toolCall = response.tool_calls?.[0];

  // 도구 호출이 없으면 에러 (tool_choice로 강제했으므로 발생하지 않아야 함)
  if (!toolCall) {
    throw new Error("Failed to generate a tool call when diagnosing error.");
  }

  // 진단 성공 로그
  logger.info("Diagnosed error successfully.", {
    diagnosis: (toolCall.args as z.infer<typeof diagnoseErrorTool.schema>)
      .diagnosis,
  });

  // === 6단계: 진단 결과를 ToolMessage로 변환 ===
  // LLM의 진단을 성공적인 ToolMessage로 감싸서 반환
  // 이렇게 하면 다음 노드에서 진단 내용을 컨텍스트로 사용 가능
  const toolMessage = new ToolMessage({
    id: uuidv4(),                     // 고유 메시지 ID
    tool_call_id: toolCall.id ?? "",  // 원본 도구 호출 ID
    content: `Successfully diagnosed error. Please use the diagnosis to continue with the next action.`,
    name: toolCall.name,
    status: "success",                 // 진단 자체는 성공
    additional_kwargs: {
      is_diagnosis: true,              // 이 메시지가 진단 결과임을 표시
    },
  });

  // === 7단계: 상태 업데이트 반환 ===
  return {
    messages: [response, toolMessage], // AI 응답과 진단 결과
    tokenData: trackCachePerformance(response, modelName), // 캐싱 성능 추적
  };
}
